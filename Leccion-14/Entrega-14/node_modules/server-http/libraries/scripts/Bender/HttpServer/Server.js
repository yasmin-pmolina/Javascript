/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

var config = require("configuration-processor").configurationProcessor,
    flowInspector = require("flow-inspector"),
    http = require("http"),
    Connection = require(__dirname + "/Connection"),
    ConnectionAggregator = require(__dirname + "/ConnectionAggregator"),
    IncomingRequest = require(__dirname + "/Message/Incoming/Request"),
    InternalServerError = require(__dirname + "/Stream/InternalServerError"),
    OutcomingResponse = require(__dirname + "/Message/Outcoming/Response"),
    OutcomingResponseQueue = require(__dirname + "/MessageQueue/Outcoming/Response"),
    Server, // constructor, function
    ServerConfiguration = require(__dirname + "/ServerConfiguration"),
    Task = flowInspector.Task,
    normalizeConnection, // private, function
    normalizeIncomingRequest, // private, function
    normalizeOutcomingResponse, // private, function
    onRawConnection, // private, function
    onRawIncomingRequest; // private, function

/**
 * @access private
 * @param {Date} date
 * @param {Bender/HttpServer/Server} httpServer
 * @param {net/Socket} socket
 * @return {Bender/HttpServer/Message/Incoming/Request}
 */
normalizeConnection = function (httpServer, socket) {
    var connection = new Connection(socket);

    // incoming request is completed at this time
    connection.start();

    return connection;
};

/**
 * @access private
 * @param {Date} date
 * @param {Bender/HttpServer/Server} httpServer
 * @param {http/IncomingMessage} request
 * @param {http/ServerResponse} response
 * @return {Bender/HttpServer/Message/Incoming/Request}
 */
normalizeIncomingRequest = function (httpServer, date, request, response) {
    var incomingRequest = new IncomingRequest(date, request);

    // incoming request is completed at this time
    incomingRequest.start();
    incomingRequest.done();

    return incomingRequest;
};

/**
 * @access private
 * @param {Date} date
 * @param {Bender/HttpServer/Server} httpServer
 * @param {Bender/HttpServer/Message/Incoming/Request} incomingRequest
 * @param {http/ServerResponse} response
 * @return {Bender/HttpServer/Message/Incoming/Request}
 */
normalizeOutcomingResponse = function (httpServer, date, incomingRequest, response) {
    var outcomingResponse = new OutcomingResponse(date, incomingRequest, response);

    outcomingResponse.start();

    return outcomingResponse;
};

/**
 * @access private
 * @param {Bender/HttpServer/Server} httpServer
 * @param {net/Socket} socket
 * @return {void}
 */
onRawConnection = function (httpServer, socket) {
    var connection = normalizeConnection(httpServer, socket),
        connectionAggregator = httpServer.connectionAggregator;

    connectionAggregator.add(connection);
    connection.addListenerStop(connectionAggregator.remove.bind(connectionAggregator, connection));

    httpServer.notifyIncomingConnection(connection);
};

/**
 * @access private
 * @param {Bender/HttpServer/Server} httpServer
 * @return {void}
 */
onRawIncomingRequest = function (httpServer, request, response) {
    var date = new Date(),
        incomingRequest = normalizeIncomingRequest(httpServer, date, request, response),
        internalServerError = new InternalServerError(),
        outcomingResponse = normalizeOutcomingResponse(httpServer, date, incomingRequest, response);

    if (httpServer.isStopping() || !httpServer.isStarted()) {
        outcomingResponse.stream(internalServerError).addListenerStop(function (evt) {
            outcomingResponse.fail();
        });
    } else {
        httpServer.onIncomingRequest(incomingRequest);
        httpServer.onOutcomingResponse(outcomingResponse);
    }
};

/**
 * @auguments flow-inspector/Task
 * @constructor
 * @param {Bender/HttpServer/ServerConfiguration|object} options
 */
Server = function (options) {
    var encapsulatedServer;

    Task.call(this);

    Object.defineProperty(this, "options", {
        value: new ServerConfiguration(options)
    });

    Object.defineProperty(this, "encapsulatedServer", {
        /**
         * @return {http/Server|void}
         */
        get: function () {
            return encapsulatedServer;
        },

        /**
         * @param {http/Server} item
         * @return {void}
         */
        set: function (item) {
            encapsulatedServer = config.assertInstanceOf(http.Server, item);
        }
    });

    this.encapsulatedServer = http.createServer(onRawIncomingRequest.bind(null, this));
    this.encapsulatedServer.addListener("connection", onRawConnection.bind(null, this));

    this.outcomingResponseQueue = new OutcomingResponseQueue();
    this.connectionAggregator = new ConnectionAggregator();
};
Server.prototype = Object.create(Task.prototype);

Object.defineProperties(Server.prototype, {
    address: {
        /**
         * @return {object}
         * @throws {Error} if server is not started
         */
        get: function () {
            if (!this.isStarted()) {
                throw new Error("Server must be started to get its address.");
            }

            return this.encapsulatedServer.address();
        }
    }
});

/**
 * @constant {string}
 */
Object.defineProperty(Server, "EVENT_INCOMING_CONNECTION", {
    value: "event.incoming.connection"
});

/**
 * @constant {string}
 */
Object.defineProperty(Server, "EVENT_INCOMING_REQUEST", {
    value: "event.incoming.request"
});

/**
 * @constant {string}
 */
Object.defineProperty(Server, "EVENT_OUTCOMING_RESPONSE", {
    value: "event.outcoming.response"
});

/**
 * @constant {string}
 */
Object.defineProperty(Server, "HOSTNAME_LOCALHOST", {
    value: process.env.NODE_LOCALHOST || "127.0.0.1"
});

/**
 * @param {function} listener
 */
Server.prototype.addListenerIncomingConnection = function (listener) {
    this.addListener(Server.EVENT_INCOMING_CONNECTION, listener);
};

/**
 * @param {function} listener
 */
Server.prototype.addListenerIncomingRequest = function (listener) {
    this.addListener(Server.EVENT_INCOMING_REQUEST, listener);
};

/**
 * @param {function} listener
 */
Server.prototype.addListenerOutcomingResponse = function (listener) {
    this.addListener(Server.EVENT_OUTCOMING_RESPONSE, listener);
};

/**
 * Order of closing connections matters here.
 *
 * @param {mixed} data
 * @return {flow-inspector/Task}
 */
Server.prototype.close = function (data) {
    var closingTask = new Task(),
        connectionAggregator = this.connectionAggregator,
        onConnectionAggregatorStopped,
        onOutcomingResponseStopped,
        outcomingResponseQueue = this.outcomingResponseQueue,
        shutdownTimeout = this.options.shutdownTimeout;

    closingTask.start();
    connectionAggregator.setShutdownTimeout(shutdownTimeout);

    onConnectionAggregatorStopped = function () {
        closingTask.done();
    };

    onOutcomingResponseStopped = function () {
        connectionAggregator.fail(data);
        connectionAggregator.onceEveryStop(onConnectionAggregatorStopped);
    };

    outcomingResponseQueue.fail(data);
    outcomingResponseQueue.onceEveryStop(onOutcomingResponseStopped);

    return closingTask;
};

/**
 * @return {array}
 */
Server.prototype.getSupportedEvents = function () {
    return Task.prototype.getSupportedEvents().concat([
        Server.EVENT_INCOMING_CONNECTION,
        Server.EVENT_INCOMING_REQUEST,
        Server.EVENT_OUTCOMING_RESPONSE
    ]);
};

/**
 * @param {Bender/HttpServer/Connection} connection
 * @return {void}
 */
Server.prototype.notifyIncomingConnection = function (connection) {
    connection = config.assertInstanceOf(Connection, connection);

    this.dispatch(Server.EVENT_INCOMING_CONNECTION, {
        connection: connection
    });
};

/**
 * @param {Bender/HttpServer/Message/Incoming/Request} request
 * @return {void}
 */
Server.prototype.notifyIncomingRequest = function (request) {
    request = config.assertInstanceOf(IncomingRequest, request);

    this.dispatch(Server.EVENT_INCOMING_REQUEST, {
        request: request
    });
};

/**
 * @param {Bender/HttpServer/Message/Outcoming/Response} response
 * @return {void}
 */
Server.prototype.notifyOutcomingResponse = function (response) {
    response = config.assertInstanceOf(OutcomingResponse, response);

    this.dispatch(Server.EVENT_OUTCOMING_RESPONSE, {
        response: response
    });
};

/**
 * @param {Bender/HttpServer/Message/Incoming/Request} request
 * @return {void}
 */
Server.prototype.onIncomingRequest = function (request) {
    request = config.assertInstanceOf(IncomingRequest, request);

    this.notifyIncomingRequest(request);
};

/**
 * @param {Bender/HttpServer/Message/Outcoming/Response} response
 * @return {void}
 * @throws {Error} if outcoming response is stopped
 */
Server.prototype.onOutcomingResponse = function (response) {
    response = config.assertInstanceOf(OutcomingResponse, response);

    if (response.isStopped()) {
        throw new Error("Outcoming response is stopped.");
    }

    this.outcomingResponseQueue.add(response);
    response.onceStopped(this.outcomingResponseQueue.remove.bind(this.outcomingResponseQueue, response));

    this.notifyOutcomingResponse(response);
};

/**
 * @param {mixed} [data] custom data passed to start event listeners
 * @return {void}
 */
Server.prototype.start = function (data) {
    var options = this.options;

    this.starting(data);

    this.encapsulatedServer.on("listening", this.doStart.bind(this, data));
    this.encapsulatedServer.listen(options.port, options.hostname);
};

/**
 * @param {mixed} [data] custom data passed to start event listeners
 * @return {void}
 */
Server.prototype.stop = function (data) {
    var closeServer,
        doStop;

    this.stopping(data);

    doStop = this.doStop.bind(this, data);
    closeServer = this.encapsulatedServer.close.bind(this.encapsulatedServer, doStop);

    this.close(data).onceStopped(closeServer);
};

module.exports = Server;
