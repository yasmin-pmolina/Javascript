/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

var config = require("configuration-processor").configurationProcessor,
    http = require("http"),
    IncomingRequest = require(__dirname + "/../Incoming/Request"),
    MessageConfiguration = require(__dirname + "/../../MessageConfiguration"),
    OutcomingMessage = require(__dirname + "/../Outcoming"),
    Response, // constructor, function
    Stream = require(__dirname + "/../../Stream"),
    Task = require("flow-inspector").Task,
    assertMessageFragment, // private, function
    onResponseStop; // private, function

/**
 * @access private
 * @param {Bender/HttpServer/Message/Outcoming/Response} response
 * @param {Bender/HttpServer/MessageConfiguration} fragment
 * @return {Bender/HttpServer/MessageConfiguration}
 */
assertMessageFragment = function (response, fragment) {
    return config.assertInstanceOf(MessageConfiguration, fragment);
};

/**
 * @access private
 * @param {Bender/HttpServer/Message/Outcoming/Response} response
 * @param {object} evt
 * @return {void}
 */
onResponseStop = function (response, evt) {
    if (!response.isStopped()) {
        // it seems that response may be stopped either by 'close' event or by
        // undocumented (at the time of writing this) 'finished' event at
        // random rate depending on internal nodejs state
        response.doStop(response.notificationData);
    }
};

/**
 * @auguments Bender/HttpServer/Message/Outcoming
 * @constructor
 * @param {Date} date
 * @param {Bender/HttpServer/Message/Incoming/Request} request
 * @param {http/ServerResponse} response
 */
Response = function (date, request, response) {
    var onStop = onResponseStop.bind(null, this);

    OutcomingMessage.call(this, date);

    this.request = config.assertInstanceOf(IncomingRequest, request);
    this.response = config.assertInstanceOf(http.ServerResponse, response);

    this.response.addListener("close", onStop);
    this.response.addListener("finish", onStop);
};
Response.prototype = Object.create(OutcomingMessage.prototype);

/**
 * @param {string} [encoding]
 * @param {Buffer|string} data
 * @return {void}
 */
Response.prototype.send = function (encoding, data) {
    this.response.write(data, encoding);
};

/**
 * @param {Bender/HttpServer/MessageConfiguration} options
 * @retunr {void}
 * @throws {Error} if headers are already sent
 */
Response.prototype.sendHeaders = function (options) {
    options = config.assertInstanceOf(MessageConfiguration, options);

    if (this.response.headersSent) {
        throw new Error("Headers already sent.");
    }

    this.response.writeHead(options.statusCode, options.reasonPhrase, options.headers);
};

/**
 * @param {mixed} [data]
 * @return {void}
 */
Response.prototype.stop = function (data) {
    this.stopping(data);

    this.notificationData = data;
    this.response.end();
};

/**
 * @param {Bender/HttpServer/Stream} stream
 * @return {flow-inspector/Task}
 */
Response.prototype.stream = function (stream) {
    var streamingTask;

    stream = config.assertInstanceOf(Stream, stream);

    streamingTask = new Task();
    streamingTask.start();

    if (!this.response.headersSent) {
        this.sendHeaders(stream.options);
    }

    stream.addListener("error", streamingTask.fail.bind(streamingTask));
    stream.pipe(this.response);

    return streamingTask;
};

module.exports = Response;
