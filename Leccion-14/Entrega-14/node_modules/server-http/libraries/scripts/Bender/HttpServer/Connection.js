/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

var config = require("configuration-processor").configurationProcessor,
    net = require("net"),
    Connection, // constructor, function
    Task = require("flow-inspector").Task;

/**
 * @auguments package/Task
 * @constructor
 * @param {net/Socket} socket
 */
Connection = function (socket) {
    Task.call(this);

    this.socket = config.assertInstanceOf(net.Socket, socket);

    this.socket.addListener("close", this.onSocketClose.bind(this));
    this.socket.addListener("timeout", this.onSocketTimeout.bind(this));
};
Connection.prototype = Object.create(Task.prototype);

/**
 * @event Bender/HttpServer/Connection#EVENT_CLOSE
 * @type {object}
 * @property {Bender/HttpServer/Connection} dispatcher
 * @property {string} directory
 */
Object.defineProperty(Connection, "EVENT_CLOSE", {
    value: "connection.event.close"
});

/**
 * @event Bender/HttpServer/Connection#EVENT_TIMEOUT
 * @type {object}
 * @property {Bender/HttpServer/Connection} dispatcher
 * @property {string} directory
 */
Object.defineProperty(Connection, "EVENT_TIMEOUT", {
    value: "connection.event.close"
});

/**
 * @return {array}
 */
Connection.prototype.getSupportedEvents = function () {
    return Task.prototype.getSupportedEvents.call(this).concat([
        Connection.EVENT_CLOSE,
        Connection.EVENT_TIMEOUT
    ]);
};

/**
 * @param {function} listener
 * @return {void}
 */
Connection.prototype.notifyClose = function (data) {
    this.dispatch(Connection.EVENT_CLOSE, data);
};

/**
 * @param {function} listener
 * @return {void}
 */
Connection.prototype.notifyTimeout = function (data) {
    this.dispatch(Connection.EVENT_TIMEOUT, data);
};

/**
 * @param {Bender/HttpServer/Connection} connection
 * @param {object} evt
 * @return {void}
 */
Connection.prototype.onSocketClose = function (evt) {
    this.doStop(this.notificationData);
    this.notifyClose(this.notificationData);
};

/**
 * @param {Bender/HttpServer/Connection} connection
 * @param {object} evt
 * @return {void}
 */
Connection.prototype.onSocketTimeout = function (evt) {
    // this.socket.destroy();
    this.notifyTimeout(this.notificationData);
};

/**
 * @param {number} miliseconds
 * @return {void}
 * @throws {Error} if connection is stopped
 */
Connection.prototype.setShutdownTimeout = function (miliseconds) {
    miliseconds = config.assertInt(miliseconds);
    if (this.isStopped()) {
        throw new Error("Connection is stopped and shutdown timeout cannot be set.");
    }

    this.socket.setTimeout(miliseconds);
};

/**
 * @param {mixed} data
 * @return {void}
 */
Connection.prototype.stop = function (data) {
    this.stopping(data);
    this.notificationData = data;

    this.socket.end();
};

module.exports = Connection;
