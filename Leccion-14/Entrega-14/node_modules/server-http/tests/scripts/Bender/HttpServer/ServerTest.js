/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

/* global after: false, afterEach: false, before: false, describe: false, it: false */

var assert = require("assert"),
    fs = require("fs"),
    http = require("http"),
    server = require(global.MODULE_ROOT + "/libraries/modules/server-http"),
    // IncomingRequest = require(global.MODULE_ROOT + "/libraries/scripts/Bender/HttpServer/Message/Incoming/Request"),
    OutcomingResponse = require(global.MODULE_ROOT + "/libraries/scripts/Bender/HttpServer/Message/Outcoming/Response"),
    Server = require(global.MODULE_ROOT + "/libraries/scripts/Bender/HttpServer/Server"),
    Stream = require(global.MODULE_ROOT + "/libraries/scripts/Bender/HttpServer/Stream");

describe("Bender/HttpServer/Server", function () {
    var httpServer,
        stopServer, // private, function
        testPortNumber;

    /**
     * @param {function} done
     * @return {void}
     */
    stopServer = function (done) {
        assert.ok(httpServer.isStarted());

        httpServer.stop();
        httpServer.addListenerStop(function (evt) {
            done();
        });
    };

    before(function (done) {
        server.findAvailablePort(function (port) {
            testPortNumber = port;

            done();
        });
    });

    describe("#start", function () {
        afterEach(stopServer);

        it("starts http-server", function (done) {
            httpServer = new Server({
                port: testPortNumber
            });

            httpServer.start();

            assert.ok(!httpServer.isStarted());
            httpServer.addListenerStart(function (evt) {
                assert.ok(httpServer.isStarted());
                assert.strictEqual(httpServer.address.port, testPortNumber);

                done();
            });
        });

        it("choses random available port from ephemeral ports range", function (done) {
            httpServer = new Server();

            httpServer.start();

            assert.ok(!httpServer.isStarted());
            httpServer.addListenerStart(function (evt) {
                assert.ok(httpServer.isStarted());
                assert.ok(httpServer.address.port);

                done();
            });
        });
    });

    describe("#stop", function () {
        it("does not allow new incoming requests while stopping", function (done) {
            var request;

            httpServer = new Server({
                port: testPortNumber
            });

            httpServer.start();

            assert.ok(!httpServer.isStarted());
            httpServer.addListenerStart(function (evt) {
                assert.strictEqual(httpServer.address.port, testPortNumber);
                httpServer.stopping();
                request = http.request({
                    hostname: httpServer.options.hostname,
                    port: httpServer.options.port
                }, function (response) {
                    assert.strictEqual(response.statusCode, 500);

                    httpServer.close().onceDone(function (evt) {
                        httpServer.encapsulatedServer.close(httpServer.doStop.bind(httpServer));
                    });
                });
                request.end();
            });

            httpServer.addListenerStop(function (evt) {
                done();
            });
        });

        it("ends all enqueued requests before stopping server", function (done) {
            var request;

            httpServer = new Server({
                port: testPortNumber
            });

            httpServer.start();

            assert.ok(!httpServer.isStarted());
            httpServer.addListenerStart(function (evt) {
                assert.strictEqual(httpServer.address.port, testPortNumber);
                request = http.request({
                    hostname: httpServer.options.hostname,
                    port: httpServer.options.port
                });
                request.end();
            });

            httpServer.addListenerOutcomingResponse(function (evt) {
                assert.ok(evt.response instanceof OutcomingResponse);
                assert.ok(!evt.response.isStopped());

                httpServer.stop();
            });

            httpServer.addListenerStop(function (evt) {
                done();
            });
        });

        describe("stopping with open response stream", function () {
            after(function (done) {
                httpServer.stop();

                assert.ok(!httpServer.isStopped());
                httpServer.addListenerStop(function (evt) {
                    done();
                });
            });

            before(function (done) {
                httpServer = new Server({
                    port: testPortNumber
                });

                httpServer.start();
                assert.ok(!httpServer.isStarted());
                httpServer.addListenerStart(function (evt) {
                    done();
                });
            });

            it("stops all requests even if streamed response is not drained", function (done) {
                var lipsum = fs.readFileSync(global.MODULE_ROOT_TESTS + "/fixtures/lipsum.txt"),
                    readableStream,
                    readableStreamLength = 2,
                    request;

                // it seems that http stream data is chunked by 64KB
                // more than one data chunk is needed to perform this test
                // correctly
                while (lipsum.length <= 65536) {
                    lipsum += lipsum;
                }

                readableStream = new Stream({
                    statusCode: 200
                });
                readableStream._read = function () {
                    readableStreamLength -= 1;
                    if (readableStreamLength < 1) {
                        this.push(null);
                    } else {
                        this.push(lipsum);
                    }
                };

                httpServer.addListenerIncomingConnection(function (evt) {
                    evt.connection.socket.setNoDelay(false);
                });

                httpServer.addListenerOutcomingResponse(function (evt) {
                    var response = evt.response;

                    response.stream(readableStream).onceDone(function () {
                        response.done();
                    });
                });

                request = http.request({
                    hostname: httpServer.options.hostname,
                    port: httpServer.address.port
                }, function (response) {
                    // server graceful shutdown timeout should interfere here
                    // and kill connection
                    done();
                });
                request.end();
            });
        });
    });
});
