/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

/* global define: false */

define([
    "Bender/EventDispatcher/EventDispatcher",
    "Bender/EventDispatcher/EventDispatcher/Repository"
], function (EventDispatcher, Repository) {

    var EventAggregator, // constructor, function

        createEventProxy, // private, function
        detachEventProxies; // private, function

    /**
     * @access private
     * @param {Bender/EventDispatcher/EventAggregator} eventAggregator
     * @param {string} eventName
     * @return {function}
     */
    createEventProxy = function (eventAggregator, eventName) {
        var eventProxy;

        if (!eventAggregator.proxies.hasOwnProperty(eventName)) {
            eventAggregator.proxies[eventName] = [];
        }

        eventProxy = eventAggregator.dispatch.bind(eventAggregator, eventName);
        eventAggregator.proxies[eventName].push(eventProxy);

        return eventProxy;
    };

    /**
     * @access private
     * @param {Bender/EventDispatcher/EventAggregator} eventAggregator
     * @param {Bender/EventDispatcher/EventDispatcher} eventDispatcher
     * @param {string} eventName
     * @return {void}
     */
    detachEventProxies = function (eventAggregator, eventDispatcher, eventName) {
        var i,
            proxies = eventAggregator.proxies[eventName];

        for (i = 0; i < proxies.length; i += 1) {
            eventDispatcher.removeListener(eventName, proxies[i]);
            proxies.splice(i, 1);
        }

        if (proxies.length < 1) {
            delete eventAggregator.proxies[eventName];
        }
    };

    /**
     * @auguments Bender/Repository/Repository
     * @constructor
     */
    EventAggregator = function () {
        Repository.call(this);

        this.proxies = {};
    };
    EventAggregator.prototype = Object.create(Repository.prototype);

    /**
     * @return {array}
     */
    EventAggregator.prototype.getSupportedEvents = function () {
        return Object.keys(this.proxies);
    };

    /**
     * @param {Bender/EventDispatcher/EventDispatcher} eventDispatcher
     * @return {bool}
     */
    EventAggregator.prototype.isItemAllowed = function (eventDispatcher) {
        return eventDispatcher instanceof EventDispatcher;
    };

    /**
     * @param {Bender/EventDispatcher/EventDispatcher} eventDispatcher
     * @return {void}
     */
    EventAggregator.prototype.notifyItemAdded = function (eventDispatcher) {
        var i,
            supportedEvents = eventDispatcher.getSupportedEvents();

        for (i = 0; i < supportedEvents.length; i += 1) {
            eventDispatcher.addListener(supportedEvents[i], createEventProxy(this, supportedEvents[i]));
        }
    };

    /**
     * @param {Bender/EventDispatcher/EventDispatcher} eventDispatcher
     * @return {void}
     */
    EventAggregator.prototype.notifyItemRemoved = function (eventDispatcher) {
        var i,
            supportedEvents = eventDispatcher.getSupportedEvents();

        for (i = 0; i < supportedEvents.length; i += 1) {
            if (this.proxies.hasOwnProperty(supportedEvents[i])) {
                detachEventProxies(this, eventDispatcher, supportedEvents[i]);
            }
        }
    };

    /**
     * @return {void}
     */
    EventAggregator.prototype.notifyRepositoryEmpty = function () {
        // throttle all empty repository notifications
    };

    /**
     * @return {void}
     */
    EventAggregator.prototype.notifyRepositoryNotEmpty = function () {
        // throttle all not empty repository notifications
    };

    return EventAggregator;

});
