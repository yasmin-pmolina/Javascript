/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

/* global define: false */

define([
    "Bender/EventDispatcher/Event",
    "Bender/EventDispatcher/EventDispatcher"
], function (Event, EventDispatcher) {

    var Repository, // constructor, function
        assertInputIsCompatibleWithRepository, // private, function
        convertToRepository; // private, function

    /**
     * @param {Bender/EventDispatcher/Repository} repository
     * @param {mixed} input
     * @return {void}
     * @throws {Error} if input is not compatible
     */
    assertInputIsCompatibleWithRepository = function (repository, input) {
        if (!Array.isArray(input) && !(input instanceof Repository)) {
            throw new Error("Expected input to be Array or instance of Bender/EventDispatcher/Repository. " + input + " given.");
        }
    };

    /**
     * @param {Bender/EventDispatcher/Repository} repository
     * @param {mixed} input
     * @return {Bender/EventDispatcher/Repository}
     */
    convertToRepository = function (repository, input) {
        assertInputIsCompatibleWithRepository(repository, input);

        if (input instanceof Repository) {
            return input;
        }

        return new Repository(input);
    };

    /**
     * @auguments Bender/EventDispatcher/EventDispatcher
     * @constructor
     * @param {array} items
     */
    Repository = function (items) {
        EventDispatcher.call(this);

        Object.defineProperty(this, "items", {
            enumerable: false,
            value: []
        });

        Object.defineProperty(this, "length", {
            enumerable: true,
            get: this.getLength.bind(this)
        });

        if (items) {
            this.setAll(items);
        }
    };
    Repository.prototype = Object.create(EventDispatcher.prototype);

    Object.defineProperty(Repository, "EVENT_ITEM_ADDED", {
        value: "event.item.added"
    });
    Object.defineProperty(Repository, "EVENT_ITEM_REMOVED", {
        value: "event.item.removed"
    });
    Object.defineProperty(Repository, "EVENT_REPOSITORY_EMPTY", {
        value: "event.repository.empty"
    });
    Object.defineProperty(Repository, "EVENT_REPOSITORY_NOT_EMPTY", {
        value: "event.repository.not.empty"
    });

    /**
     * @param {mixed} item
     * @return {void}
     * @throws {Error} if item is not allowed in this repository
     * @throws {Error} if this repository already holds given item
     */
    Repository.prototype.add = function (item) {
        if (!this.isItemAllowed(item)) {
            throw new Error("Item is not allowed in this repository: " + item);
        }

        if (this.isForcedToBeUnique() && this.has(item)) {
            throw new Error("This repository already holds item: " + item);
        }

        this.items.push(item);

        this.notifyItemAdded(item);

        if (1 === this.items.length) {
            this.notifyRepositoryNotEmpty();
        }
    };

    /**
     * @param {Bender/Repository/Repository} guestRepository
     * @return {void}
     */
    Repository.prototype.addAll = function (guestRepository) {
        guestRepository.forEach(function (item, index, items) {
            if (!this.has(item)) {
                this.add(item);
            }
        }, this);
    };

    /**
     * @param {mixed} item
     * @return {int} position of item on the list (same as indexOf)
     */
    Repository.prototype.find = function (item) {
        return this.items.indexOf(item);
    };

    /**
     * @param {function} callback
     * @param {object} thisArg
     * @return {void}
     */
    Repository.prototype.forEach = function (callback, thisArg) {
        this.items.forEach(callback, thisArg);
    };

    /**
     * @return {int}
     */
    Repository.prototype.getLength = function () {
        return this.items.length;
    };

    /**
     * @return {array}
     */
    Repository.prototype.getSupportedEvents = function () {
        return [
            Repository.EVENT_ITEM_ADDED,
            Repository.EVENT_ITEM_REMOVED,
            Repository.EVENT_REPOSITORY_EMPTY,
            Repository.EVENT_REPOSITORY_NOT_EMPTY
        ];
    };

    /**
     * @param {mixed} item
     * @return {bool}
     */
    Repository.prototype.has = function (item) {
        /*jshint bitwise: false */
        return (~this.find(item));
    };

    /**
     * @return {bool}
     */
    Repository.prototype.isForcedToBeUnique = function () {
        return false;
    };

    /**
     * @param {mixed} item
     * @return {bool}
     */
    Repository.prototype.isItemAllowed = function (item) {
        return true;
    };

    /**
     * @fires Bender/EventDispatcher/Repository#EVENT_ITEM_ADDED
     * @param {mixed} item
     * @return {void}
     */
    Repository.prototype.notifyItemAdded = function (item) {
        this.dispatch(Repository.EVENT_ITEM_ADDED, new Event({
            repository: this,
            item: item
        }));
    };

    /**
     * @fires Bender/EventDispatcher/Repository#EVENT_ITEM_REMOVED
     * @param {mixed} item
     * @return {void}
     */
    Repository.prototype.notifyItemRemoved = function (item) {
        this.dispatch(Repository.EVENT_ITEM_REMOVED, new Event({
            repository: this,
            item: item
        }));
    };

    /**
     * @fires Bender/EventDispatcher/Repository#EVENT_REPOSITORY_EMPTY
     * @param {mixed} item
     * @return {void}
     */
    Repository.prototype.notifyRepositoryEmpty = function () {
        this.dispatch(Repository.EVENT_REPOSITORY_EMPTY, new Event({
            repository: this
        }));
    };

    /**
     * @fires Bender/EventDispatcher/Repository#EVENT_REPOSITORY_NOT_EMPTY
     * @param {mixed} item
     * @return {void}
     */
    Repository.prototype.notifyRepositoryNotEmpty = function () {
        this.dispatch(Repository.EVENT_REPOSITORY_NOT_EMPTY, new Event({
            repository: this
        }));
    };

    /**
     * @fires Bender/Repository/Repository#EVENT_GAMEPAD_PLUGGED_OUT
     * @param {mixed} item
     * @return {void}
     * @throws {Error} if this repository does not hold given item
     */
    Repository.prototype.remove = function (item) {
        if (!this.has(item)) {
            throw new Error("This repository does not hold item: " + item);
        }

        this.items.splice(this.find(item), 1);
        this.notifyItemRemoved(item);

        if (0 === this.items.length) {
            this.notifyRepositoryEmpty();
        }
    };

    /**
     * @param {array|Bender/Repository/Repository} other
     * @return {void}
     */
    Repository.prototype.removeAllExcept = function (other) {
        var i,
            items = this.items.slice();

        other = convertToRepository(this, other);

        for (i = 0; i < items.length; i += 1) {
            if (!other.has(items[i])) {
                this.remove(items[i]);
            }
        }
    };

    /**
     * @param {array|Bender/Repository/Repository} other
     * @return {void}
     */
    Repository.prototype.setAll = function (other) {
        assertInputIsCompatibleWithRepository(this, other);

        if (this.items.length < 1) {
            other.forEach(this.add, this);
        } else {
            other = convertToRepository(this, other);

            this.removeAllExcept(other);
            this.addAll(other);
        }
    };

    return Repository;

});
