/**
 * @license Copyright (c) 2013, CKSource - Frederico Knabben
 * For licensing, see LICENSE
 */

"use strict";

/* global define: false */

(function (factory) {

    if ("function" === typeof define) {
        define([
            "configuration-processor/configuration-processor",
            "event-dispatcher/EventDispatcher"
        ], factory);
    } else {
        module.exports = factory.apply(null, [
            require("configuration-processor"),
            require("event-dispatcher").EventDispatcher
        ]);
    }

}(function (configurationProcessor, EventDispatcher) {

    var config = configurationProcessor.configurationProcessor,
        Task, // constructor, function
        defineDateProperty, // private, function
        notifyStateChanged; // private, function

    /**
     * @access private
     * @param {JsLoader/FlowInspector/Task} task
     * @param {string} propertyName
     * @return {void}
     */
    defineDateProperty = function (task, propertyName) {
        var date;

        Object.defineProperty(task, propertyName, {
            /**
             * @return {Date}
             */
            get: function () {
                return date;
            },

            /**
             * @param {Date} item
             * @return {void}
             */
            set: function (item) {
                date = config.assertInstanceOf(Date, item);
            }
        });
    };

    /**
     * Changing state may be not obvious when using custom methods in child
     * objects.
     *
     * @access private
     * @param {JsLoader/FlowInspector/Task} task
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     */
    notifyStateChanged = function (task, data) {
        // order of dispatching matters here
        if (task.isStarting() && !task.isDispatched(Task.EVENT_STARTING)) {
            task.notifyStarting(data);
        }
        if (task.isStarted() && !task.isDispatched(Task.EVENT_START)) {
            task.notifyStart(data);
        }

        if (task.isStopping() && !task.isDispatched(Task.EVENT_STOPPING)) {
            task.notifyStopping(data);
        }
        if (task.isStopped() && !task.isDispatched(Task.EVENT_STOP)) {
            task.notifyStop(data);
        }

        if (task.isDone() && !task.isDispatched(Task.EVENT_DONE)) {
            task.notifyDone(data);
        }
        if (task.isFailed() && !task.isDispatched(Task.EVENT_FAIL)) {
            task.notifyFail(data);
        }
    };

    /**
     * This object represents atomic task that cannot be paused in the middle.
     *
     * @auguments event-dispatcher/EventDispatcher
     * @constructor
     */
    Task = function () {
        EventDispatcher.call(this);

        defineDateProperty(this, "startDate");
        defineDateProperty(this, "startSequenceDate");
        defineDateProperty(this, "stopDate");
        defineDateProperty(this, "stopSequenceDate");
    };
    Task.prototype = Object.create(EventDispatcher.prototype);

    /**
     * @event JsLoader/FlowInspector/Task#EVENT_DONE
     * @type {object}
     * @property {JsLoader/FlowInspector/Task} task
     */
    Object.defineProperty(Task, "EVENT_DONE", {
        enumerable: true,
        value: "event.done",
        writable: false
    });

    /**
     * @event JsLoader/FlowInspector/Task#EVENT_FAIL
     * @type {object}
     * @property {JsLoader/FlowInspector/Task} task
     */
    Object.defineProperty(Task, "EVENT_FAIL", {
        enumerable: true,
        value: "event.fail",
        writable: false
    });

    /**
     * @event JsLoader/FlowInspector/Task#EVENT_START
     * @type {object}
     * @property {JsLoader/FlowInspector/Task} task
     */
    Object.defineProperty(Task, "EVENT_START", {
        enumerable: true,
        value: "event.start",
        writable: false
    });

    /**
     * @event JsLoader/FlowInspector/Task#EVENT_STARTING
     * @type {object}
     * @property {JsLoader/FlowInspector/Task} task
     */
    Object.defineProperty(Task, "EVENT_STARTING", {
        enumerable: true,
        value: "event.starting",
        writable: false
    });

    /**
     * @event JsLoader/FlowInspector/Task#EVENT_STOP
     * @type {object}
     * @property {JsLoader/FlowInspector/Task} task
     */
    Object.defineProperty(Task, "EVENT_STOP", {
        enumerable: true,
        value: "event.stop",
        writable: false
    });

    /**
     * @event JsLoader/FlowInspector/Task#EVENT_STOPPING
     * @type {object}
     * @property {JsLoader/FlowInspector/Task} task
     */
    Object.defineProperty(Task, "EVENT_STOPPING", {
        enumerable: true,
        value: "event.stopping",
        writable: false
    });

    Object.defineProperty(Task, "ERROR_GENERIC", {
        enumerable: true,
        value: 1,
        writable: false
    });

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.addListenerDone = function (listener) {
        this.addListener(Task.EVENT_DONE, listener);
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.addListenerFail = function (listener) {
        this.addListener(Task.EVENT_FAIL, listener);
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.addListenerStart = function (listener) {
        this.addListener(Task.EVENT_START, listener);
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.addListenerStarting = function (listener) {
        this.addListener(Task.EVENT_STARTING, listener);
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.addListenerStop = function (listener) {
        this.addListener(Task.EVENT_STOP, listener);
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.addListenerStopping = function (listener) {
        this.addListener(Task.EVENT_STOPPING, listener);
    };

    /**
     * @return {bool}
     */
    Task.prototype.canStart = function () {
        return !this.isStarted() && !this.isStarting();
    };

    /**
     * @return {bool}
     */
    Task.prototype.canStop = function () {
        return this.isStarted() && !this.isStopping();
    };

    /**
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     * @throws {Error} if task is done already
     */
    Task.prototype.done = function (data) {
        if (this.isDone()) {
            throw new Error("Task is already marked as done.");
        }

        this.doneData = data;
        this.stop(data);

        notifyStateChanged(this, data);
    };

    /**
     * @param {mixed} [data]
     * @return {void}
     * @throws {Error} if task is already started
     */
    Task.prototype.doStart = function (data) {
        if (this.isStarted()) {
            throw new Error("Task is already started.");
        }

        this.startData = data;
        this.startDate = new Date();
        notifyStateChanged(this, data);
    };

    /**
     * @param {mixed} [data]
     * @return {void}
     * @throws {Error} if task is already stopped
     */
    Task.prototype.doStop = function (data) {
        if (this.isStopped()) {
            throw new Error("Task is already stopped.");
        }

        this.stopData = data;
        this.stopDate = new Date();
        notifyStateChanged(this, data);
    };

    /**
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     * @throws {Error} if task is failed already
     */
    Task.prototype.fail = function (data) {
        if (this.isFailed()) {
            throw new Error("Task is already marked as failed.");
        }

        this.failData = data;
        this.stop(data);

        notifyStateChanged(this, data);
    };

    /**
     * @return {array}
     */
    Task.prototype.getSupportedEvents = function () {
        return [
            Task.EVENT_DONE,
            Task.EVENT_FAIL,
            Task.EVENT_START,
            Task.EVENT_STARTING,
            Task.EVENT_STOP,
            Task.EVENT_STOPPING
        ];
    };

    /**
     * @return {bool}
     */
    Task.prototype.isNotifiedDone = function () {
        return this.hasOwnProperty("doneEvent");
    };

    /**
     * @return {bool}
     */
    Task.prototype.isNotifiedFail = function () {
        return this.hasOwnProperty("failEvent");
    };

    /**
     * @return {bool}
     */
    Task.prototype.isNotifiedStart = function () {
        return this.hasOwnProperty("startEvent");
    };

    /**
     * @return {bool}
     */
    Task.prototype.isNotifiedStarting = function () {
        return this.hasOwnProperty("startingEvent");
    };

    /**
     * @return {bool}
     */
    Task.prototype.isNotifiedStop = function () {
        return this.hasOwnProperty("stopEvent");
    };

    /**
     * @return {bool}
     */
    Task.prototype.isNotifiedStopping = function () {
        return this.hasOwnProperty("stoppingEvent");
    };

    /**
     * @return {bool}
     */
    Task.prototype.isDone = function () {
        return this.hasOwnProperty("doneData") && this.isStopped();
    };

    /**
     * @return {bool}
     */
    Task.prototype.isFailed = function () {
        return this.hasOwnProperty("failData") && this.isStopped();
    };

    /**
     * @return {bool}
     */
    Task.prototype.isStarted = function () {
        return !!this.startDate && !this.stopDate;
    };

    /**
     * @return {bool}
     */
    Task.prototype.isStarting = function () {
        return !!this.startSequenceDate && !this.startDate;
    };

    /**
     * @return {bool}
     */
    Task.prototype.isStopped = function () {
        return !!this.stopDate;
    };

    /**
     * @return {bool}
     */
    Task.prototype.isStopping = function () {
        return !!this.stopSequenceDate && !this.stopDate;
    };

    /**
     * @param {mixed} [data]
     * @return {mixed}
     */
    Task.prototype.normalizeTaskData = function (data) {
        return data;
    };

    /**
     * @fires JsLoader/FlowInspector/Task#EVENT_DONE
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.notifyDone = function (data) {
        if (this.isNotifiedDone()) {
            throw new Error("Task already notified listeners about being done.");
        }

        this.doneEvent = this.dispatch(Task.EVENT_DONE, this.normalizeTaskData(data));
    };

    /**
     * @fires JsLoader/FlowInspector/Task#EVENT_FAIL
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.notifyFail = function (data) {
        if (this.isNotifiedFail()) {
            throw new Error("Task already notified listeners about being failed.");
        }

        this.failEvent = this.dispatch(Task.EVENT_FAIL, this.normalizeTaskData(data));
    };

    /**
     * @fires JsLoader/FlowInspector/Task#EVENT_START
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.notifyStart = function (data) {
        if (this.isNotifiedStart()) {
            throw new Error("Task already notified listeners about being started.");
        }

        this.startEvent = this.dispatch(Task.EVENT_START, this.normalizeTaskData(data));
    };

    /**
     * @fires JsLoader/FlowInspector/Task#EVENT_STARTING
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.notifyStarting = function (data) {
        if (this.isNotifiedStarting()) {
            throw new Error("Task already notified listeners about starting.");
        }

        this.startingEvent = this.dispatch(Task.EVENT_STARTING, this.normalizeTaskData(data));
    };

    /**
     * @fires JsLoader/FlowInspector/Task#EVENT_STOP
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.notifyStop = function (data) {
        if (this.isNotifiedStop()) {
            throw new Error("Task already notified listeners about being stopped.");
        }

        this.stopEvent = this.dispatch(Task.EVENT_STOP, this.normalizeTaskData(data));
    };

    /**
     * @fires JsLoader/FlowInspector/Task#EVENT_STOPPING
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.notifyStopping = function (data) {
        if (this.isNotifiedStopping()) {
            throw new Error("Task already notified listeners about stopping.");
        }

        this.stoppingEvent = this.dispatch(Task.EVENT_STOPPING, this.normalizeTaskData(data));
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.onceDone = function (listener) {
        if (this.isDone()) {
            listener(this.doneEvent);
        } else {
            this.addListenerDone(listener);
        }
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.onceFailed = function (listener) {
        if (this.isFailed()) {
            listener(this.failEvent);
        } else {
            this.addListenerFail(listener);
        }
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.onceStarted = function (listener) {
        if (this.isStarted()) {
            listener(this.startEvent);
        } else {
            this.addListenerStart(listener);
        }
    };

    /**
     * @param {function} listener
     * @return {void}
     */
    Task.prototype.onceStopped = function (listener) {
        if (this.isStopped()) {
            listener(this.stopEvent);
        } else {
            this.addListenerStop(listener);
        }
    };

    /**
     * @param {mixed} [data]
     * @return {void}
     */
    Task.prototype.ready = function (data) {
        this.start(data);
        this.done(data);
    };

    /**
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     * @throws {Error} if task is already started
     */
    Task.prototype.start = function (data) {
        if (!this.canStart()) {
            throw new Error("Task cannot be started. Most probably task is running.");
        }

        this.starting(data);
        this.doStart(data);
    };

    /**
     * Indicate that this task is starting but not yet fully started.
     *
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     * @throws {Error} if task is already starting
     */
    Task.prototype.starting = function (data) {
        if (this.isStarting()) {
            throw new Error("Task is already marked as starting.");
        }

        this.startSequenceDate = new Date();
        notifyStateChanged(this, data);
    };

    /**
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     * @throws {Error} if task is already stopped
     */
    Task.prototype.stop = function (data) {
        if (!this.canStop()) {
            throw new Error("Task cannot be stopped. Most probably task is not running.");
        }

        this.stopping(data);
        this.doStop(data);
    };

    /**
     * Indicate that this task is starting but not yet fully stopped.
     *
     * @param {mixed} [data] data passed to notification event
     * @return {void}
     * @throws {Error} if task is already starting
     */
    Task.prototype.stopping = function (data) {
        if (this.isStopping()) {
            throw new Error("Task is already marked as stopping.");
        }

        this.stopSequenceDate = new Date();
        notifyStateChanged(this, data);
    };

    return Task;

}));
